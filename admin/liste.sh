#!/bin/bash

# Script de gestion et listage des scripts personnels
# Auteur: NDXDev@gmail.com
# Usage: ./list-scripts.sh [--detailed] [--run SCRIPT] [--help]

# Configuration
SCRIPTS_DIR="$HOME/scripts"

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
NC='\033[0m'
BOLD='\033[1m'

# Variables pour options
DETAILED=false
RUN_SCRIPT=""
SHOW_HELP=false

# Fonction d'affichage avec couleurs
print_message() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Fonction d'aide
show_help() {
    echo "Usage: $0 [OPTIONS]"
    echo
    echo "Gestionnaire et listage des scripts personnels"
    echo
    echo "Options:"
    echo "  -h, --help              Afficher cette aide"
    echo "  -d, --detailed          Affichage d√©taill√© avec descriptions"
    echo "  -r, --run SCRIPT        Ex√©cuter un script interactivement"
    echo "  -i, --info SCRIPT       Informations d√©taill√©es sur un script"
    echo "  -e, --edit SCRIPT       √âditer un script"
    echo "  --check                 V√©rifier l'int√©grit√© des scripts"
    echo "  --stats                 Statistiques des scripts"
    echo
    echo "Exemples:"
    echo "  $0                      # Liste simple"
    echo "  $0 -d                   # Liste d√©taill√©e"
    echo "  $0 -r update-debian     # Ex√©cuter update-debian.sh"
    echo "  $0 -i backup-config     # Infos sur backup-config.sh"
}

# Fonction pour extraire la description d'un script
get_script_description() {
    local script_file=$1

    if [ ! -f "$script_file" ]; then
        echo "Script non trouv√©"
        return
    fi

    # Chercher les commentaires de description en d√©but de fichier
    local description=$(head -10 "$script_file" | grep -E "^#.*[Ss]cript|^#.*[Dd]escription|^#.*[Aa]uteur" | head -1 | sed 's/^# *//')

    if [ -z "$description" ]; then
        # Chercher dans les 20 premi√®res lignes un commentaire explicatif
        description=$(head -20 "$script_file" | grep -E "^#.*[Pp]our|^#.*[Gg]estion|^#.*[Mm]onitor|^#.*[Nn]ettoyage|^#.*[Ss]auvegarde|^#.*[Aa]udit" | head -1 | sed 's/^# *//')
    fi

    if [ -z "$description" ]; then
        echo "Aucune description disponible"
    else
        echo "$description"
    fi
}

# Fonction pour obtenir la taille d'un fichier
get_file_size() {
    local file=$1
    if [ -f "$file" ]; then
        local size=$(stat -c%s "$file")
        if [ $size -lt 1024 ]; then
            echo "${size}B"
        elif [ $size -lt 1048576 ]; then
            echo "$((size/1024))KB"
        else
            echo "$((size/1048576))MB"
        fi
    else
        echo "N/A"
    fi
}

# Fonction pour obtenir la date de modification
get_modification_date() {
    local file=$1
    if [ -f "$file" ]; then
        stat -c %y "$file" | cut -d' ' -f1
    else
        echo "N/A"
    fi
}

# Fonction pour v√©rifier si un script est ex√©cutable
is_executable() {
    local file=$1
    if [ -x "$file" ]; then
        echo "‚úì"
    else
        echo "‚úó"
    fi
}

# Fonction pour compter les lignes de code
count_lines() {
    local file=$1
    if [ -f "$file" ]; then
        wc -l < "$file"
    else
        echo "0"
    fi
}

# Fonction de listage simple
list_scripts_simple() {
    print_message $BOLD "üìÅ Scripts disponibles dans $SCRIPTS_DIR"
    echo

    if [ ! -d "$SCRIPTS_DIR" ]; then
        print_message $RED "‚ùå R√©pertoire $SCRIPTS_DIR non trouv√©"
        return 1
    fi

    local script_count=0

    # Header du tableau
    printf "${CYAN}%-25s %-12s %-12s %-8s${NC}\n" "NOM" "TAILLE" "MODIFI√â" "EXEC"
    print_message $CYAN "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

    # Lister tous les fichiers .sh
    for script in "$SCRIPTS_DIR"/*.sh; do
        if [ -f "$script" ]; then
            local basename=$(basename "$script")
            local size=$(get_file_size "$script")
            local mod_date=$(get_modification_date "$script")
            local executable=$(is_executable "$script")

            # Couleur selon l'√©tat ex√©cutable
            if [ "$executable" = "‚úì" ]; then
                printf "${GREEN}%-25s${NC} %-12s %-12s %-8s\n" "$basename" "$size" "$mod_date" "$executable"
            else
                printf "${YELLOW}%-25s${NC} %-12s %-12s ${RED}%-8s${NC}\n" "$basename" "$size" "$mod_date" "$executable"
            fi

            script_count=$((script_count + 1))
        fi
    done

    echo
    print_message $BLUE "üìä Total: $script_count scripts trouv√©s"

    if [ $script_count -eq 0 ]; then
        print_message $YELLOW "üí° Aucun script .sh trouv√© dans $SCRIPTS_DIR"
        print_message $CYAN "   Cr√©ez vos scripts avec: nano $SCRIPTS_DIR/mon-script.sh"
    fi
}

# Fonction de listage d√©taill√©
list_scripts_detailed() {
    print_message $BOLD "üìÅ Scripts d√©taill√©s dans $SCRIPTS_DIR"
    echo

    if [ ! -d "$SCRIPTS_DIR" ]; then
        print_message $RED "‚ùå R√©pertoire $SCRIPTS_DIR non trouv√©"
        return 1
    fi

    local script_count=0

    for script in "$SCRIPTS_DIR"/*.sh; do
        if [ -f "$script" ]; then
            local basename=$(basename "$script" .sh)
            local size=$(get_file_size "$script")
            local mod_date=$(get_modification_date "$script")
            local executable=$(is_executable "$script")
            local lines=$(count_lines "$script")
            local description=$(get_script_description "$script")

            # Affichage avec style
            print_message $BOLD "üîß $basename"
            echo "   üìÑ Fichier: $(basename "$script")"
            echo "   üìä Taille: $size ($lines lignes)"
            echo "   üìÖ Modifi√©: $mod_date"
            echo -n "   üîë Ex√©cutable: "
            if [ "$executable" = "‚úì" ]; then
                print_message $GREEN "$executable"
            else
                print_message $RED "$executable (chmod +x requis)"
            fi
            echo "   üìù Description: $description"

            # Tenter d'extraire l'usage si disponible
            local usage=$(grep -E "^# Usage:" "$script" | head -1 | sed 's/^# Usage: *//')
            if [ -n "$usage" ]; then
                echo "   üí° Usage: $usage"
            fi

            echo
            script_count=$((script_count + 1))
        fi
    done

    print_message $BLUE "üìä Total: $script_count scripts analys√©s"
}

# Fonction pour afficher les informations d'un script sp√©cifique
show_script_info() {
    local script_name=$1
    local script_file="$SCRIPTS_DIR/${script_name}.sh"

    # Permettre avec ou sans extension
    if [ ! -f "$script_file" ]; then
        script_file="$SCRIPTS_DIR/${script_name}"
    fi

    if [ ! -f "$script_file" ]; then
        print_message $RED "‚ùå Script '$script_name' non trouv√© dans $SCRIPTS_DIR"
        return 1
    fi

    local basename=$(basename "$script_file")
    local size=$(get_file_size "$script_file")
    local mod_date=$(get_modification_date "$script_file")
    local executable=$(is_executable "$script_file")
    local lines=$(count_lines "$script_file")
    local description=$(get_script_description "$script_file")

    print_message $BOLD "üìã Informations d√©taill√©es: $basename"
    echo
    print_message $CYAN "üìÅ Chemin complet: $script_file"
    print_message $CYAN "üìä Taille: $size"
    print_message $CYAN "üìè Lignes de code: $lines"
    print_message $CYAN "üìÖ Derni√®re modification: $mod_date"

    echo -n "üîë Ex√©cutable: "
    if [ "$executable" = "‚úì" ]; then
        print_message $GREEN "Oui"
    else
        print_message $RED "Non (chmod +x requis)"
    fi

    print_message $CYAN "üìù Description: $description"

    # Permissions d√©taill√©es
    local perms=$(stat -c %A "$script_file")
    print_message $CYAN "üîê Permissions: $perms"

    # Chercher les options disponibles
    echo
    print_message $BLUE "üí° Options disponibles:"
    grep -E "^\s*-[a-zA-Z].*\)" "$script_file" | head -10 | while read option; do
        echo "   $option"
    done

    # Afficher l'aide si disponible
    if grep -q "\-\-help\|show_help" "$script_file"; then
        echo
        print_message $GREEN "‚ÑπÔ∏è  Aide disponible avec: $basename --help"
    fi
}

# Fonction pour ex√©cuter un script interactivement
run_script_interactive() {
    local script_name=$1
    local script_file="$SCRIPTS_DIR/${script_name}.sh"

    # Permettre avec ou sans extension
    if [ ! -f "$script_file" ]; then
        script_file="$SCRIPTS_DIR/${script_name}"
    fi

    if [ ! -f "$script_file" ]; then
        print_message $RED "‚ùå Script '$script_name' non trouv√©"
        return 1
    fi

    if [ ! -x "$script_file" ]; then
        print_message $YELLOW "‚ö†Ô∏è  Script non ex√©cutable. Correction automatique..."
        chmod +x "$script_file"
        print_message $GREEN "‚úì Permissions corrig√©es"
    fi

    print_message $BOLD "üöÄ Ex√©cution de: $(basename "$script_file")"
    echo

    # Proposer les options courantes
    echo "Options rapides:"
    echo "  1) Ex√©cution normale"
    echo "  2) Aide (--help)"
    echo "  3) Mode simulation (--dry-run)"
    echo "  4) Mode d√©taill√© (-v ou --verbose)"
    echo "  5) Commande personnalis√©e"
    echo

    read -p "Choisissez une option (1-5): " choice

    case $choice in
        1)
            print_message $BLUE "Ex√©cution normale..."
            "$script_file"
            ;;
        2)
            print_message $BLUE "Affichage de l'aide..."
            "$script_file" --help
            ;;
        3)
            print_message $BLUE "Mode simulation..."
            "$script_file" --dry-run
            ;;
        4)
            print_message $BLUE "Mode d√©taill√©..."
            "$script_file" -v
            ;;
        5)
            read -p "Entrez les arguments: " custom_args
            print_message $BLUE "Ex√©cution avec: $custom_args"
            "$script_file" $custom_args
            ;;
        *)
            print_message $YELLOW "Option invalide, ex√©cution normale"
            "$script_file"
            ;;
    esac
}

# Fonction d'√©dition de script
edit_script() {
    local script_name=$1
    local script_file="$SCRIPTS_DIR/${script_name}.sh"

    # Permettre avec ou sans extension
    if [ ! -f "$script_file" ]; then
        script_file="$SCRIPTS_DIR/${script_name}"
    fi

    if [ ! -f "$script_file" ]; then
        print_message $RED "‚ùå Script '$script_name' non trouv√©"
        return 1
    fi

    print_message $BLUE "üìù √âdition de: $(basename "$script_file")"

    # D√©tecter l'√©diteur disponible
    if command -v nano >/dev/null; then
        nano "$script_file"
    elif command -v vim >/dev/null; then
        vim "$script_file"
    else
        print_message $RED "‚ùå Aucun √©diteur trouv√© (nano, vim)"
        return 1
    fi

    print_message $GREEN "‚úì √âdition termin√©e"
}

# Fonction de v√©rification d'int√©grit√©
check_scripts_integrity() {
    print_message $BOLD "üîç V√©rification de l'int√©grit√© des scripts"
    echo

    local total=0
    local executable=0
    local issues=0

    for script in "$SCRIPTS_DIR"/*.sh; do
        if [ -f "$script" ]; then
            total=$((total + 1))
            local basename=$(basename "$script")

            # V√©rifier l'ex√©cutabilit√©
            if [ -x "$script" ]; then
                executable=$((executable + 1))
                print_message $GREEN "‚úì $basename"
            else
                print_message $YELLOW "‚ö† $basename (non ex√©cutable)"
                issues=$((issues + 1))
            fi

            # V√©rifier la syntaxe bash
            if ! bash -n "$script" 2>/dev/null; then
                print_message $RED "‚úó $basename (erreur de syntaxe)"
                issues=$((issues + 1))
            fi
        fi
    done

    echo
    print_message $BLUE "üìä R√©sum√©:"
    print_message $CYAN "   Scripts totaux: $total"
    print_message $GREEN "   Ex√©cutables: $executable"
    print_message $YELLOW "   Probl√®mes: $issues"

    if [ $issues -eq 0 ]; then
        print_message $GREEN "üéâ Tous les scripts sont en bon √©tat!"
    else
        print_message $YELLOW "üí° Corrigez les permissions avec: chmod +x ~/scripts/*.sh"
    fi
}

# Fonction de statistiques
show_statistics() {
    print_message $BOLD "üìà Statistiques des scripts"
    echo

    if [ ! -d "$SCRIPTS_DIR" ]; then
        print_message $RED "‚ùå R√©pertoire non trouv√©"
        return 1
    fi

    local total_scripts=0
    local total_lines=0
    local total_size=0
    local executable_count=0

    for script in "$SCRIPTS_DIR"/*.sh; do
        if [ -f "$script" ]; then
            total_scripts=$((total_scripts + 1))
            total_lines=$((total_lines + $(count_lines "$script")))

            local size=$(stat -c%s "$script")
            total_size=$((total_size + size))

            if [ -x "$script" ]; then
                executable_count=$((executable_count + 1))
            fi
        fi
    done

    print_message $CYAN "üìä Nombre de scripts: $total_scripts"
    print_message $CYAN "üìè Total lignes de code: $total_lines"
    print_message $CYAN "üíæ Taille totale: $(( total_size / 1024 )) KB"
    print_message $CYAN "üîë Scripts ex√©cutables: $executable_count/$total_scripts"

    if [ $total_scripts -gt 0 ]; then
        local avg_lines=$((total_lines / total_scripts))
        print_message $CYAN "üìä Moyenne lignes/script: $avg_lines"
    fi

    echo
    print_message $BLUE "üèÜ Script le plus volumineux:"
    find "$SCRIPTS_DIR" -name "*.sh" -exec wc -l {} \; | sort -nr | head -1 | while read lines file; do
        print_message $GREEN "   $(basename "$file"): $lines lignes"
    done
}

# Analyse des arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -d|--detailed)
            DETAILED=true
            shift
            ;;
        -r|--run)
            RUN_SCRIPT="$2"
            shift 2
            ;;
        -i|--info)
            show_script_info "$2"
            exit 0
            ;;
        -e|--edit)
            edit_script "$2"
            exit 0
            ;;
        --check)
            check_scripts_integrity
            exit 0
            ;;
        --stats)
            show_statistics
            exit 0
            ;;
        *)
            print_message $RED "Option inconnue: $1"
            show_help
            exit 1
            ;;
    esac
done

# Fonction principale
main() {
    # Header avec style
    print_message $PURPLE "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    print_message $PURPLE "‚ïë                    üõ†Ô∏è  GESTIONNAIRE DE SCRIPTS               ‚ïë"
    print_message $PURPLE "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo

    # V√©rifier que le r√©pertoire scripts existe
    if [ ! -d "$SCRIPTS_DIR" ]; then
        print_message $YELLOW "üìÅ R√©pertoire $SCRIPTS_DIR non trouv√©"
        print_message $CYAN "üí° Cr√©ation automatique..."
        mkdir -p "$SCRIPTS_DIR"
        print_message $GREEN "‚úì R√©pertoire cr√©√©"
        echo
    fi

    # Ex√©cution selon les options
    if [ -n "$RUN_SCRIPT" ]; then
        run_script_interactive "$RUN_SCRIPT"
    elif [ "$DETAILED" = true ]; then
        list_scripts_detailed
    else
        list_scripts_simple
    fi

    echo
    print_message $CYAN "üí° Utilisez --help pour voir toutes les options disponibles"
}

# Point d'entr√©e
main "$@"
